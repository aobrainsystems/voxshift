import fs from "node:fs";
import path from "node:path";
import { google } from "googleapis";
import type { youtube_v3 } from "googleapis";
import type { YouTubeUploadInput, YouTubeUploadMetadata, YouTubeUploadResult, YouTubePrivacyStatus } from "./types.js";

const MAX_TITLE_LENGTH = 100;
const MAX_DESCRIPTION_LENGTH = 5000;

interface ResolvedUploadMetadata {
  title: string;
  description: string;
  tags?: string[];
  categoryId?: string;
  privacyStatus: YouTubePrivacyStatus;
  defaultLanguage?: string;
  defaultAudioLanguage?: string;
  madeForKids?: boolean;
  playlistId?: string;
}

function truncate(value: string, maxLength: number): string {
  if (value.length <= maxLength) {
    return value;
  }
  return `${value.slice(0, maxLength - 1)}...`;
}

function normalizeLanguageCode(language: string | undefined): string {
  const trimmed = (language ?? "").trim();
  return trimmed || "en";
}

function normalizeTags(tags: string[] | undefined): string[] | undefined {
  if (!tags || tags.length === 0) {
    return undefined;
  }

  const unique = [...new Set(tags.map((tag) => tag.trim()).filter(Boolean))];
  return unique.length > 0 ? unique : undefined;
}

function buildDefaultTitle(input: { sourceTitle?: string; outputVideoPath: string; targetLanguage: string }): string {
  const baseSourceTitle =
    input.sourceTitle?.trim() || path.parse(input.outputVideoPath).name.replaceAll(/[_-]+/g, " ").trim() || "Untitled source";

  return truncate(`${baseSourceTitle} (${input.targetLanguage} dub)`, MAX_TITLE_LENGTH);
}

function buildDefaultDescription(input: {
  sourceVideoUrl?: string;
  sourceVideoId?: string;
  sourceChannelTitle?: string;
}): string {
  const lines = ["Automated dubbed output generated by VoxShift."];

  if (input.sourceVideoUrl) {
    lines.push(`Source video: ${input.sourceVideoUrl}`);
  }

  if (input.sourceVideoId) {
    lines.push(`Source video ID: ${input.sourceVideoId}`);
  }

  if (input.sourceChannelTitle) {
    lines.push(`Source channel: ${input.sourceChannelTitle}`);
  }

  lines.push("Rights acknowledgement: publishing operator confirms rights to create and publish this dubbed derivative.");
  return truncate(lines.join("\n"), MAX_DESCRIPTION_LENGTH);
}

function normalizePrivacyStatus(value: string | undefined): YouTubePrivacyStatus {
  if (value === "public" || value === "unlisted" || value === "private") {
    return value;
  }
  return "private";
}

function resolveUploadMetadata(input: YouTubeUploadInput): ResolvedUploadMetadata {
  const metadata = input.metadata;
  const targetLanguage = normalizeLanguageCode(input.fallbackTargetLanguage ?? metadata.defaultLanguage ?? metadata.defaultAudioLanguage);

  const title = truncate(
    metadata.title?.trim() || buildDefaultTitle({
      sourceTitle: input.fallbackSourceTitle,
      outputVideoPath: input.outputVideoPath,
      targetLanguage,
    }),
    MAX_TITLE_LENGTH,
  );

  const description = truncate(
    metadata.description?.trim() ||
      buildDefaultDescription({
        sourceVideoUrl: input.fallbackSourceVideoUrl,
        sourceVideoId: input.fallbackSourceVideoId,
        sourceChannelTitle: input.fallbackSourceChannelTitle,
      }),
    MAX_DESCRIPTION_LENGTH,
  );

  const defaultLanguage = normalizeLanguageCode(metadata.defaultLanguage ?? targetLanguage);
  const defaultAudioLanguage = normalizeLanguageCode(metadata.defaultAudioLanguage ?? defaultLanguage);

  return {
    title,
    description,
    tags: normalizeTags(metadata.tags),
    categoryId: metadata.categoryId?.trim() || undefined,
    privacyStatus: normalizePrivacyStatus(metadata.privacyStatus),
    defaultLanguage,
    defaultAudioLanguage,
    madeForKids: metadata.madeForKids,
    playlistId: metadata.playlistId?.trim() || undefined,
  };
}

async function getAuthenticatedChannel(youtube: youtube_v3.Youtube): Promise<{ id: string; title: string }> {
  try {
    const channelResponse = await youtube.channels.list({
      part: ["id", "snippet"],
      mine: true,
      maxResults: 1,
    });

    const channel = channelResponse.data.items?.[0];
    const channelId = channel?.id?.trim();

    if (!channelId) {
      throw new Error("Unable to resolve authenticated YouTube channel via channels.list(mine=true).");
    }

    return {
      id: channelId,
      title: channel?.snippet?.title?.trim() || "",
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    if (message.toLowerCase().includes("insufficient authentication scopes")) {
      throw new Error(
        "OAuth token is missing scopes required for channel verification. " +
          "Recreate refresh token with BOTH scopes: " +
          "https://www.googleapis.com/auth/youtube.upload and " +
          "https://www.googleapis.com/auth/youtube.readonly",
      );
    }
    throw error;
  }
}

export function buildYouTubeUploadMetadata(input: {
  metadata?: YouTubeUploadMetadata;
  targetLanguage?: string;
  sourceTitle?: string;
  sourceChannelTitle?: string;
  sourceVideoId?: string;
  sourceVideoUrl?: string;
  outputVideoPath: string;
}): YouTubeUploadMetadata {
  const defaultTitle = buildDefaultTitle({
    sourceTitle: input.sourceTitle,
    outputVideoPath: input.outputVideoPath,
    targetLanguage: normalizeLanguageCode(input.targetLanguage),
  });

  const defaultDescription = buildDefaultDescription({
    sourceVideoUrl: input.sourceVideoUrl,
    sourceVideoId: input.sourceVideoId,
    sourceChannelTitle: input.sourceChannelTitle,
  });

  return {
    title: input.metadata?.title ?? defaultTitle,
    description: input.metadata?.description ?? defaultDescription,
    tags: input.metadata?.tags,
    categoryId: input.metadata?.categoryId,
    privacyStatus: input.metadata?.privacyStatus,
    defaultLanguage: input.metadata?.defaultLanguage ?? normalizeLanguageCode(input.targetLanguage),
    defaultAudioLanguage: input.metadata?.defaultAudioLanguage ?? normalizeLanguageCode(input.targetLanguage),
    madeForKids: input.metadata?.madeForKids,
    playlistId: input.metadata?.playlistId,
  };
}

export async function uploadDubbedVideoToYouTube(input: YouTubeUploadInput): Promise<YouTubeUploadResult> {
  if (!fs.existsSync(input.outputVideoPath)) {
    throw new Error(`Output video file not found: ${input.outputVideoPath}`);
  }

  const metadata = resolveUploadMetadata(input);

  const oauth2Client = new google.auth.OAuth2(input.oauthClientId, input.oauthClientSecret);
  oauth2Client.setCredentials({ refresh_token: input.oauthRefreshToken });

  const youtube = google.youtube({
    version: "v3",
    auth: oauth2Client,
  });

  const authenticatedChannel = await getAuthenticatedChannel(youtube);

  if (authenticatedChannel.id !== input.targetChannelId) {
    throw new Error(
      `Authenticated channel '${authenticatedChannel.id}' does not match required target '${input.targetChannelId}'.`,
    );
  }

  if (input.dryRun) {
    return {
      dryRun: true,
      privacyStatus: metadata.privacyStatus,
      title: metadata.title,
      description: metadata.description,
      tags: metadata.tags,
      categoryId: metadata.categoryId,
      defaultLanguage: metadata.defaultLanguage,
      defaultAudioLanguage: metadata.defaultAudioLanguage,
      madeForKids: metadata.madeForKids,
      playlistId: metadata.playlistId,
      authenticatedChannelId: authenticatedChannel.id,
      authenticatedChannelTitle: authenticatedChannel.title,
    };
  }

  const snippet: youtube_v3.Schema$VideoSnippet = {
    title: metadata.title,
    description: metadata.description,
    defaultLanguage: metadata.defaultLanguage,
    defaultAudioLanguage: metadata.defaultAudioLanguage,
    categoryId: metadata.categoryId,
    tags: metadata.tags,
  };

  const status: youtube_v3.Schema$VideoStatus = {
    privacyStatus: metadata.privacyStatus,
  };

  if (typeof metadata.madeForKids === "boolean") {
    status.selfDeclaredMadeForKids = metadata.madeForKids;
  }

  const insertResponse = await youtube.videos.insert({
    part: ["snippet", "status"],
    requestBody: {
      snippet,
      status,
    },
    media: {
      body: fs.createReadStream(input.outputVideoPath),
    },
  });

  const uploadedVideoId = insertResponse.data.id;
  if (!uploadedVideoId) {
    throw new Error("YouTube upload finished without returning a video ID.");
  }

  if (metadata.playlistId) {
    await youtube.playlistItems.insert({
      part: ["snippet"],
      requestBody: {
        snippet: {
          playlistId: metadata.playlistId,
          resourceId: {
            kind: "youtube#video",
            videoId: uploadedVideoId,
          },
        },
      },
    });
  }

  return {
    dryRun: false,
    privacyStatus: metadata.privacyStatus,
    title: metadata.title,
    description: metadata.description,
    tags: metadata.tags,
    categoryId: metadata.categoryId,
    defaultLanguage: metadata.defaultLanguage,
    defaultAudioLanguage: metadata.defaultAudioLanguage,
    madeForKids: metadata.madeForKids,
    playlistId: metadata.playlistId,
    authenticatedChannelId: authenticatedChannel.id,
    authenticatedChannelTitle: authenticatedChannel.title,
    uploadedVideoId,
    uploadedVideoUrl: `https://www.youtube.com/watch?v=${uploadedVideoId}`,
  };
}
